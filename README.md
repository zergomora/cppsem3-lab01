Все графики находятся в handle.ipynb

## В первом задании (first.cpp)
"переиспользовать код класса Dice в классе ThreeDicePool":
Вместо Dice будем наследоваться от полностью виртуального класса AbstractDice, состояющего из деструктора (строка 5) и virtual метода roll (строка 6) 
Это необходимо, чтобы потом все остальные наследующиеся классы могли перегрузить метод roll так, как им нужно
Переиспользование состоит во-первых в наследовании от AbstractDice (строка 22) и том, что теперь ThreeDicePool не инициализирует новые Dice для собственного пользования, а получает уже три готовых объекта Dice в качестве аргументов

"использовать только одну реализацию функции expected_value на основе полиморфизам подтипов":
Поскольку все используемые классы (такие как Dice и ThreeDicePool) наследуются от одного и того же родительского AbstractDice, то в аргумент функции expected_value можно беспрепятственно передавать, что Dice, что ThreeDicePool (хотя с виду это и два различных типа данных)

"использовать класс ThreeDicePool для любого класса, реализующего метод .roll, на основе полиморфизма подтипов":
На строке 48 мы иницилиазируем ThreeDicePool, передавая ему в конструктор три только что созданных Dice (alpha, beta и gamma)

## Во втором задании (second.cpp)
Смысл функции value_probability (см. строку 58) в том, что она делает number_of_rolls бросков и считает сколько раз (accum) выпала нужная нам величина value, а затем просто делит это на общее число  

## В третьем задании (third.cpp)
Основная мысль - в решении проблемы ромба, которая заключается в том, что PenaltyDice и BonusDice наследуются от одного и того же AbstractDice. Получается, что у первого, что и у второго имеется свой метод roll
В лабораторной приведено всего 3 способа решения этой проблемы (соответственно, три файла: third, third(without milti) и third++)

- в third.cpp: Обратите внимание на строки 23 и 35. Там мы наследуем классы от ВИРТУАЛЬНОГО класса AbstractDice и поэтому у нас по сути есть не два отдельных метода roll, а один (просто перезаписанный)
- в third(without multi).cpp: Здесь нет множественного наследования. На строке 47 мы теперь наследуемся от ПРИВАТНЫХ PenaltyDice и BonusDice. Приватность тут нужна, чтобы при наследовании дочерний класс DoubleDice не знал о существовании метода roll внутри них. Именно поэтому мы еще отдельно наследуемся от virtual public AbstractDice, чтобы завладеть виртуальным методом roll
- в third++.cpp: На строке 47 DoubleDice теперь вообще наследуется только от AbstractDice, но при этом теперь внутри своего конструктора (строка 49) он инициализирует для своих нужд PenaltyDice и BonusDice, к которым нельзя получить доступ снаружи, так как они private, но зато можно пользоваться внутри
